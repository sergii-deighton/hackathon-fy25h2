# Notification System Architecture — Summary

## 1. Core Use Cases
- Users receive notifications generated by business processes.
- Notifications can be:
  - **User-specific**
  - **Group-specific**
  - **Broadcast** (sent to all users)
- Notification payload may include:
  - Title
  - Body/message
  - Link (deep link or website)
  - Type (info, warning, onboarding, update, etc.)
  - Source (which business process generated it)
- Clicking a notification opens details or redirects the user.

## 2. Channels
- **Primary**: In-app notifications (always on, cannot opt out).
- **Optional**: Email and SMS.
  - User can enable/disable email/SMS in their profile.
  - In-app storage is always written; email/SMS are extras.

## 3. Database Structure

### Technology
- **PostgreSQL** (containerized via `docker-compose`).
- Optional DB admin UI: **pgAdmin** (or similar) in `docker-compose` for convenient inspection.

**Table: Notifications** — Stores every in-app notification.

| Column    | Description                                                      |
|-----------|------------------------------------------------------------------|
| Id        | PK                                                               |
| UserId    | Recipient (null for broadcast template)                          |
| Type      | info / warning / onboarding / update / etc.                      |
| Status    | unread / read                                                    |
| CreatedAt | timestamp                                                        |
| ReadAt    | timestamp (nullable)                                             |
| Source    | constant/enum representing business process                      |
| Title     | short text                                                       |
| Body      | main text                                                        |
| Link      | optional URL/deep link                                           |

**Table: NotificationChannelPreferences** — Per-user channel configuration.

| Column        | Description      |
|---------------|------------------|
| UserId        | FK               |
| EmailEnabled  | bool             |
| SmsEnabled    | bool             |
| InAppEnabled  | always true      |

**Broadcast handling**
- Broadcast notifications are not stored once.
- Sender generates individual notifications per user (or tasks per user) and inserts them into the DB.

## 4. Services

### A. Notification CRUD Service
Responsibilities:
- Create notification entries in DB.
-.Mark notifications as read.
- Delete notifications (optional).
- Read notifications for a user.

Role: repository/service layer for stored notifications (does not deliver).

### B. Notification Sending Service
Responsibilities:
- Consume tasks from a message queue (RabbitMQ, Service Bus, etc.).
- For each task:
  - Insert notification record(s) into DB (in-app channel).
  - Send email if enabled.
  - Send SMS if enabled.
- Uses the CRUD service internally for DB operations.

Technology:
- **RabbitMQ** for the queue (containerized in `docker-compose`).
- **MassTransit** in .NET for queue interaction and message handling.

## 5. Message Queue (RabbitMQ / Service Bus)
**Why**
- Decouple the API that creates notification tasks from the service that delivers them.
- Handle spikes, retries, durability.

**Workflow**
1. Business process calls `SendNotification(...)`.
2. Instead of sending directly, it creates a **task object** and enqueues it.
3. Notification Sender Service is subscribed to the queue.
4. For each task, it:
   - Reads user preferences.
   - Creates DB notification entry.
   - Sends email/SMS if enabled.

This yields scalability, fault tolerance, and clear separation of concerns.

## 6. Sending Workflow (Step-by-Step)
1. System generates a notification request: `SendNotification(toUserId, type, title, message, link, source)` or `SendBroadcastNotification(...)`.
2. API enqueues a task (example payload):
   ```json
   {
     "to": "userId or group or broadcast",
     "type": "info",
     "title": "New version released",
     "body": "Please update the app",
     "link": "...",
     "source": "ReleaseService"
   }
   ```
3. Notification Sender Service consumes the queue:
   - For broadcast: generate per-user notifications or tasks.
   - Insert notification into DB (in-app).
   - Check user channel prefs:
     - If email enabled -> send email.
     - If SMS enabled -> send SMS.
4. User reads notifications via the Notification CRUD Service.

## 7. Service Separation
- **Notification CRUD Service**
  - Read, create (DB only), mark as read, delete.
  - Does **not** send notifications.
  - .NET REST service (containerized) exposing Notifications/Users endpoints.
- **Notification Sender Service**
  - Subscribed to queue.
  - Sends across channels.
  - Inserts notification entries into DB.
  - .NET worker using MassTransit + RabbitMQ (containerized).

## 8. Docker Compose Topology (planned)
- `postgres`: PostgreSQL instance with volume for data.
- `pgadmin` (or similar): optional DB management UI.
- `rabbitmq`: broker for MassTransit (enable management plugin).
- `notification-api`: .NET REST service (CRUD for notifications/users) connecting to Postgres and RabbitMQ.
- `notification-worker`: .NET worker using MassTransit to consume queue tasks and send via channels; writes to Postgres.

Environment/config notes:
- Share a network between services; use internal hostnames (`postgres`, `rabbitmq`).
- Configure MassTransit to use RabbitMQ URI with credentials from environment.
- API and worker share DB connection string and queue names; keep secrets in env vars. 

## 9. Angular Frontend Architecture (proposed)
- **Presentational components**: Pure Angular, stateless, no service dependencies. Accept only `@Input()` data and emit events with `@Output()`. Render UI and raise user interactions.
- **Repository services (stateful)**: Hold local state/cache and expose streams/methods to containers. Delegate actual fetching to lower-level API services. No direct UI coupling.
- **API/low-level services (stateless)**: Thin wrappers around REST endpoints; no state, only HTTP calls.
- **Container components**: Own orchestration. Inject repositories, subscribe to their data, pass data down to presentational components via inputs, and wire outputs back to repository/API calls. Containers keep the handlers and coordination logic; presentational components stay dumb.
- Testing implication: Presentational components can be shallow-tested; containers test interaction with repositories via mocks; repositories test state transitions; API services test HTTP contracts.

## 10. Backend Stack & Data Flow (detailed)
- **Runtime**: .NET (API + Worker), Entity Framework Core for data access/migrations.
- **Persistence**: PostgreSQL (compose service) with EF Core migrations checked into the repo. Apply migrations on container startup.
- **Seeding**: Seed script (EF Core seed or hosted service) to pre-populate sample notifications/types/users for demos.
- **Messaging**: RabbitMQ (compose) with MassTransit in the worker for consuming/sending tasks.
- **API Service (REST)**:
  - Expose endpoints to read notifications, create notifications, mark read, delete, read user channel prefs, update prefs.
  - Uses EF Core DbContext; runs migrations on start.
  - Seeds demo data on start (guarded by env flag).
- **Worker Service**:
  - Subscribed to RabbitMQ via MassTransit.
  - Processes send tasks: inserts notifications, sends email/SMS (stub for now), respects channel prefs.
  - Also runs migrations/seed (or share a migration container) before consuming.
- **Migrations**:
  - Generate EF Core migrations and commit them.
  - Run via `dotnet ef database update` on API/worker start, or a dedicated migration job in compose.
- **Compose services** (summary):
  - `postgres` + volume.
  - `pgadmin` (optional UI).
  - `rabbitmq` (with management).
  - `notification-api` (.NET REST).
  - `notification-worker` (.NET worker with MassTransit).
  - Frontend dev servers stay separate (Angular/Ionic), but can point to API via env/proxy.
- **Frontend wiring**:
- Angular `NotificationsApiService` now points to the REST API (default `http://localhost:5001/api/notifications`; override with `window.NOTIFICATIONS_API_BASE` if needed).
  - Repository remains stateful and still falls back to mock data if the API is unreachable.

## 12. Demo quick-start (dev only)
- Start backend infra: `docker-compose up postgres rabbitmq notification-api notification-worker` (add `pgadmin` if you want UI).
- API swagger: `http://localhost:5001/swagger`.
- Frontend: run `docker-compose up web-spa` (or `npm start` in `apps/web-spa`). By default it targets `http://localhost:5001/api/notifications`.
- Optional override: in browser console `window.NOTIFICATIONS_API_BASE = 'http://localhost:5001/api/notifications'` then reload, if you need to point elsewhere.
- Seed data: applied automatically on API/worker startup (via EF `Migrate()` + `SeedData`).

## 11. Current Backend Implementation (checked-in)
- EF Core context and migrations live in `services/notifications-shared` (`Data/Migrations/*`); both API and worker reference the shared project and call `Database.Migrate()` + `SeedData.EnsureSeededAsync()` on startup.
- Initial migration creates `Notifications` and `NotificationChannelPreferences` with indexes/lengths aligned to the entities.
- Compose services:
  - `postgres` (5432), `pgadmin` (5050), `rabbitmq` (5672/15672), `notification-api` (exposes 5001 → 8080), `notification-worker`.
  - API exposes minimal endpoints: list/create, mark read, delete at `/api/notifications`.
- To apply migrations locally (optional since startup applies them):
  - `dotnet ef database update --project services/notifications-shared --startup-project services/notifications-api --context NotificationDbContext`
- Seeded demo data matches the UI sample (info/error/warning items plus channel prefs).
