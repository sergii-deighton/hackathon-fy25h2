# Notification System Architecture — Summary

## 1. Core Use Cases
- Users receive notifications generated by business processes.
- Notifications can be:
  - **User-specific**
  - **Group-specific**
  - **Broadcast** (sent to all users)
- Notification payload may include:
  - Title
  - Body/message
  - Link (deep link or website)
  - Type (info, warning, onboarding, update, etc.)
  - Source (which business process generated it)
- Clicking a notification opens details or redirects the user.

## 2. Channels
- **Primary**: In-app notifications (always on, cannot opt out).
- **Optional**: Email and SMS.
  - User can enable/disable email/SMS in their profile.
  - In-app storage is always written; email/SMS are extras.

## 3. Database Structure

### Technology
- **PostgreSQL** (containerized via `docker-compose`).
- Optional DB admin UI: **pgAdmin** (or similar) in `docker-compose` for convenient inspection.

**Table: Notifications** — Stores every in-app notification.

| Column    | Description                                                      |
|-----------|------------------------------------------------------------------|
| Id        | PK                                                               |
| UserId    | Recipient (null for broadcast template)                          |
| Type      | info / warning / onboarding / update / etc.                      |
| Status    | unread / read                                                    |
| CreatedAt | timestamp                                                        |
| ReadAt    | timestamp (nullable)                                             |
| Source    | constant/enum representing business process                      |
| Title     | short text                                                       |
| Body      | main text                                                        |
| Link      | optional URL/deep link                                           |

**Table: NotificationChannelPreferences** — Per-user channel configuration.

| Column        | Description      |
|---------------|------------------|
| UserId        | FK               |
| EmailEnabled  | bool             |
| SmsEnabled    | bool             |
| InAppEnabled  | always true      |

**Broadcast handling**
- Broadcast notifications are not stored once.
- Sender generates individual notifications per user (or tasks per user) and inserts them into the DB.

## 4. Services

### A. Notification CRUD Service
Responsibilities:
- Create notification entries in DB.
-.Mark notifications as read.
- Delete notifications (optional).
- Read notifications for a user.

Role: repository/service layer for stored notifications (does not deliver).

### B. Notification Sending Service
Responsibilities:
- Consume tasks from a message queue (RabbitMQ, Service Bus, etc.).
- For each task:
  - Insert notification record(s) into DB (in-app channel).
  - Send email if enabled.
  - Send SMS if enabled.
- Uses the CRUD service internally for DB operations.

Technology:
- **RabbitMQ** for the queue (containerized in `docker-compose`).
- **MassTransit** in .NET for queue interaction and message handling.

## 5. Message Queue (RabbitMQ / Service Bus)
**Why**
- Decouple the API that creates notification tasks from the service that delivers them.
- Handle spikes, retries, durability.

**Workflow**
1. Business process calls `SendNotification(...)`.
2. Instead of sending directly, it creates a **task object** and enqueues it.
3. Notification Sender Service is subscribed to the queue.
4. For each task, it:
   - Reads user preferences.
   - Creates DB notification entry.
   - Sends email/SMS if enabled.

This yields scalability, fault tolerance, and clear separation of concerns.

## 6. Sending Workflow (Step-by-Step)
1. System generates a notification request: `SendNotification(toUserId, type, title, message, link, source)` or `SendBroadcastNotification(...)`.
2. API enqueues a task (example payload):
   ```json
   {
     "to": "userId or group or broadcast",
     "type": "info",
     "title": "New version released",
     "body": "Please update the app",
     "link": "...",
     "source": "ReleaseService"
   }
   ```
3. Notification Sender Service consumes the queue:
   - For broadcast: generate per-user notifications or tasks.
   - Insert notification into DB (in-app).
   - Check user channel prefs:
     - If email enabled -> send email.
     - If SMS enabled -> send SMS.
4. User reads notifications via the Notification CRUD Service.

## 7. Service Separation
- **Notification CRUD Service**
  - Read, create (DB only), mark as read, delete.
  - Does **not** send notifications.
  - .NET REST service (containerized) exposing Notifications/Users endpoints.
- **Notification Sender Service**
  - Subscribed to queue.
  - Sends across channels.
  - Inserts notification entries into DB.
  - .NET worker using MassTransit + RabbitMQ (containerized).

## 8. Docker Compose Topology (planned)
- `postgres`: PostgreSQL instance with volume for data.
- `pgadmin` (or similar): optional DB management UI.
- `rabbitmq`: broker for MassTransit (enable management plugin).
- `notification-api`: .NET REST service (CRUD for notifications/users) connecting to Postgres and RabbitMQ.
- `notification-worker`: .NET worker using MassTransit to consume queue tasks and send via channels; writes to Postgres.

Environment/config notes:
- Share a network between services; use internal hostnames (`postgres`, `rabbitmq`).
- Configure MassTransit to use RabbitMQ URI with credentials from environment.
- API and worker share DB connection string and queue names; keep secrets in env vars. 

## 9. Angular Frontend Architecture (proposed)
- **Presentational components**: Pure Angular, stateless, no service dependencies. Accept only `@Input()` data and emit events with `@Output()`. Render UI and raise user interactions.
- **Repository services (stateful)**: Hold local state/cache and expose streams/methods to containers. Delegate actual fetching to lower-level API services. No direct UI coupling.
- **API/low-level services (stateless)**: Thin wrappers around REST endpoints; no state, only HTTP calls.
- **Container components**: Own orchestration. Inject repositories, subscribe to their data, pass data down to presentational components via inputs, and wire outputs back to repository/API calls. Containers keep the handlers and coordination logic; presentational components stay dumb.
- Testing implication: Presentational components can be shallow-tested; containers test interaction with repositories via mocks; repositories test state transitions; API services test HTTP contracts.
